
<!DOCTYPE html>
<html>
<head>

	<title>Cipher</title>
	<meta charset="utf-8" />
	<link rel="stylesheet" type="text/css" href="./common.css" />
	<link rel="stylesheet" type="text/css" href="./front.css" />

	<style>
	</style>

</head>
<body>

	<div id="sidebarWrapper">

		<div class="bar" id="padder"></div>
		<div class="bar" id="sidebar">
			<div id="sidebarInner" class="bar max">
				<button id="pressCipher"    >Main<br>Page</button>
				<button id="pressCaesar"    >Caesar</button>
				<button id="pressAlgebraic" >Algebraic</button>
				<button id="pressPoint"     >Point</button>
				<button id="pressPlace"     >Place</button>
				<button id="pressSymbol"    >Symbol</button>
				<div id="fill"></div>
			</div>
		</div>
		<div class="bar" id="underbar">
			<div class="verticalCenter" class="max">
				<h1>All Ciphers</h1>
			</div>
		</div>

	</div>

	<div id="title">
		<span id="textLeft">
			Enter the Crypt
		</span>
	</div>

	<div id="mainPage">
		<div class="section">
			<h1>How-To</h1>
			Welcome to Enter the Crypt! Hover over the sidebar on the left to display your options. At the top of it you can:
			<ul>
				<li>Access the main info page (here).</li>
				<li>Access or use any specific cipher and its information.</li>
			</ul>
			By interacting with the bottom portion, you can access saved ciphers.<br><br>

			<!-- Available ciphers:
			<ul>
				<li><a href="./public/caesar.html">Caesar Cipher</a></li>
				<li><a href="./public/algebraic.html">Custom Algebraic Cipher</a></li>
				<li><a href="./public/point.html">Code-Point Caesar Cipher</a></li>
				<li><a href="./public/place.html">In-Place Caesar Cipher</a></li>
				<li><a href="./public/symbol.html">Symbol Map Cipher</a></li>
			</ul> -->
		</div>
		<div class="section">
			<h1>Inner Workings of the Ciphers in "Enter the Crypt"</h1>
			A subsitution cipher alters each character to have a corresponding subsitute. This cipher tool aims to perform several different types of subsitution ciphers on given text.

			<br>

			<span id="unusual-behavior" style="color: var(--light)">Note that for certain subsitutions, special characters may be used that inhibit <a style="text-decoration: underline;">unusual behavior</a> on that can alter how text is rendered</span>, like the <a href="https://en.wikipedia.org/wiki/Newline">newline</a> that starts a new line or <a href="https://unicode-explorer.com/c/202E">directional overrides</a> that change character direction. Some characters might not be capable of being rendered at all, and some characters have anomolous characteristics like combining into each other like emojis or diacritics, or having unusual length (extremely large/long: "íê´", "íàô", "‚∏ª", extremely small: "‚ÄØ", "‚Ää", zero-width: "‚Ää", "Ôªø", "·†é").<br><br>
				To handle the issues of visibility and rendering, <span style="color: var(--light); text-decoration: underline;">it is advised to ALWAYS handle these unique symbols either through a text file or through a button to copy to the clipboard</span>, ensuring no loss of information or confusion when copying and saving resulting ciphered strings.

			<h2>Caesar Cipher</h2>
			The Caesar Cipher is an extremely simple cipher which ciphers an alphabet whose order is shifted forwards or backwards.<br>
			Shifting once right, ABCDXYZ -> BCDEYZA.<br>
			Shifting three time left, ABCDXYZ -> XYZAUVW.

			<h3>Benefits and Drawbacks</h3>
			The Caesar cipher is immensely easy to perform, but is also equally as easy to decode. It is one of the most common ciphers, and it is very impractical if you actually desire the contents of your message to be safe. At best, it will only thwart strict text parsers, but likely won't get past a normal person who knows even surface-level cryptography as it can even be descrypted by hand. Even worse, an English-only Caesar cipher presumes the English language, which helps narrow things down. Also, Caesar ciphers are subject to raw <a href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a> in regards to <a href="https://en.wikipedia.org/wiki/Letter_frequency">letter frequency</a>, since the frequency of letters are not at all altered in any way. Also, Caesar ciphers are traditionally case insensitive and ignore spaces and punctuation, resulting in less symbols.

			<h2>Custom Algebraic Cipher</h2>
			By using the <code>ord()</code> and <code>chr()</code> of Python (or similar methods like JS's <code>charCodeAt()</code> or <code>fromCharCode()</code> functions), one can turn individual characters in a string into numbers and vice versa based on their code points according to <a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters">Unicode</a>. This numeric alteration of a string of text allows for ciphers to be represented as mathematical equations, which is implemented by allowing users to input an equation to act as a cipher. <span style="color: yellow">Uppercase letters have different code points than lowercase letters.</span>

			<h3>Rules</h3>

			<ol>
				<li>The variable "x" must be used, with no other variables present.</li>
				<li>The equation should pass both the vertical line test AND the horizontal line test for any given inputs. In other words, there should be no repeats in either input or output for a given relation. For this reason, cyclic functions like sine waves would be invalid most of the time since they are periodic and pass through the same inputs repeatedly (failing the horizontal line test). Even-degree polynomials (e.g. parabolas) or polynomials that have bumps also can fail this, like parabolas (from squaring) that fail if there are both negative and positive results.</li>
				<li>All outputs must create an integer, and exactly an integer with no decimals.</li>
				<li>All results must range from 0-1114111 due to the Unicode limit.</li>
				<li>(extra functionality).</li>
			</ol>

			<h3>Benefits and Drawbacks</h3>
			The upsides of this technique is that it is not nearly as easily reversable as a Caesar cipher, and the key can vary VERY heavily depending on the mathematical proficiency one has to write equations that satisfy the rules above. A text parser will not be able to get any information out of it, and depending on what chatbot sees it, an AI likely will not be capable of reversing the string. However, it can be very clunky for a person who wants a quick-and-done encyption to come up with a unique equation each time they want to generate a unique key, and it is very likely a person will simply resort to using a simple linear equation each time, which can be made for more predictable keys. Also, while this can technically support all Unicode symbols from any different language, when the code points of characters that go into certain boundaries, it can be difficult to keep code points within the range of 0-1114111. Also, because each conversion is 1-1, this cipher is subject to <a href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a> in regards to <a href="https://en.wikipedia.org/wiki/Letter_frequency">letter frequency</a>, since the frequency of letters are not at all altered in any way like the Caesar cipher.<br>
			<span style="color: yellow">Additionally, because the equations can spit out arbitrary Unicode characters from the equation used, the resulting symbols are subject to the aforementioned <a href="#unusual-behavior">unusual behavior</a></span>.

			<h2>Code Point Caesar Cipher</h2>
			Like the Caesar Cipher, a cipher can be made to shift a set of characters in a direction. However, instead of using only the alphabet, this special cipher can use Unicode code points from before as a range to shift around. The range is inherent to the given string, with the lower bound being the lowest found code point, and the upper bound being the highest found code point.<br>
			For example, "abcdABCD" maps to "97 98 99 100 65 66 67 68". Our lowest code point is 65, and our highest code point is 100. Our values should wrap between "65" and "100" for any given shift.
			Thus, to shift right five times, we should get:<br>
			<code>
			97 98 99 100 65 66 67 68<br>
			‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì<br>
			66 67 68 69&nbsp;  70 71 72 73<br>
			</code>
			This translates to "BCDEFGHI". Like the original Caesar cipher, if your string does not contain the entire range of shifting characters, you are bound to gain or lose characters in your string that were not there before. "a"/"b"/"c"/"d"/"A" are no longer present, while we get the new characters "E"/"F"/"G"/"H"/"I". Our unique symbol count remains the same, while the symbols we use to represent any given letter do not.<br>
			A very important detail! This cipher is not inherently decipherable if you lack the original range used to create the ciphered text. The range of new charcters is from 66-73, not 65-100. In other words, the range that could produce the ciphered text is a superset of the ciphered text's range, and thus the original range used is ambiguous and can map to MANY different possible ranges. Because of this, even though you only need the mathematical shift key in order to <span style="font-style: italic;">generate</span> the cipher, you will need the shift key <span style="font-weight: bold;">AND</span> the original range to decipher it.

			<h3>Benefits and Drawbacks</h3>
			This specific type of cipher, to our knowledge, is not widely available at a first-glance. This was simply a cipher created on a whim for this project. Thus, it is probably not a stock cipher you would find online in any place other than here. To crack it, it would require a more advanced knowledge of Unicode code points as well as general cryptography. It will absolutely go under the radar of text parsers, and very likely under the radar of current modern-day AI. Still, however, this cipher is subject to <a href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a> in regards to <a href="https://en.wikipedia.org/wiki/Letter_frequency">letter frequency</a>, since the frequency of letters are not at all altered in any way, akin to the original Caesar cipher.<br><br>
			HOWEVER, unlike the original Caesar cipher, this cipher is not restricted to the Latin alphabet only. All symbols for languages that Unicode has support for can be used, so coding messages in different languages can help mess up frequency analysis, as different analysis techniques will have to be used for different languages. Distribution analysis for a language such as written Chinese would be extremely hard to pull off compared to English, as the number of symbols used in the language for normal day-to-day conversation ranges in the thousands. This completely blows English out of the water, having the most-used symbols be only 52 lowercase+uppercase letters, with 10 numeric symbols, a space symbol, a comma and period, and newlines. However, since numbers/spaces/punctuation/newlines are MUCH less common than normal letters, and because uppercase is much less common than lowercase without special text methods, the English language crumbles hard from Frequency Analysis due to its lack of numerous evenly-distributed symbols. Innate and unambiguous multi-language support is an EXTREME upside over the traditional Caesar cipher in the hands of the right person.<br>
			<span style="color: yellow">Note that because the range of Unicode characters can range from the lowest to the highest, with either one being arbitrary depending on the string's contents and potentially covering hundreds or even thousands of characters, the resulting symbols are subject to the aforementioned <a href="#unusual-behavior">unusual behavior</a></span>. This can be very useful however, as because the symbols generated in the encrypted string can be formed in an arbitrary range, if even one Unicode symbol goes far into the thousands range then the symbols between the original string and the ciphered string may not even match at all, which means that the symbols in the original string may not even be deductable from the encrypted string.

			<h2>In-Place Caesar Cipher</h2>
			This is similar to the last cipher, the range defined based on the string itself. However, this time, we get the code points ordered in ascending order, and then we shift each code point to the right or left.<br>
			For example, "acdAAABCDDD" maps to "97 99 100 65 65 65 66 67 68 68 68". Sorted in ascending order, we get "65 66 67 68 97 99 100". Shifting over left one gives "66 67 68 97 99 100 65". Thus, 65 maps to 66, 66 maps to 67, 68 maps to 97, etc.<br>
			<code>
			97 99&nbsp; 100 65 65 65 66 67 68 68 68<br>
			‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;&nbsp;‚Üì&nbsp;&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì&nbsp;&nbsp;‚Üì<br>
			99 100 65&nbsp; 66 66 66 67 68 97 97 97<br>
			</code>

			This new code matches to cdABBBCDaaa, which is made up of all of the same letters from the previous string without adding any additional letters, unlike the last cipher where new letters could appear and old ones could vanish.

			<h3>Benefits and Drawbacks</h3>
			The upsides and downsides mostly match that of the Code Point Caesar Cipher. It wasn't an idea from another place, so it's not likely you'll find a pre-made internet tool capable of breaking this specific type cipher directly. It is slightly better than the Caesar cipher in terms of baseline safety due to it not being a basicly common cipher, but it still suffers from Frequency Analysis with English, but the additional support of any language usable in Unicode makes it a much better choice of simplicity.
			<span style="color:rgb(0,255,0)">Note that because all characters are in-place and do not use extra arbitrary symbols that reside outside of the original string, the resulting symbols are not subject to <a href="#unusual-behavior">unusual behavior</a>.</span> The only common odd-case that should occur would be if newlines get shuffled into a common character, or if your method of storing strings snips consecutive spaces in strings were spaces get shuffled to repeat.<br>
			<span style="color:orange">One major weakness this cipher has compared to the previous cipher is that the ciphered text is made enitrely out of the symbols in the original text due to being completely in-place. This means that while the use of arbitrary symbols that may cause unusual behavior will not occur, the general form of the original string can still be inferred DIRECTLY from the ciphered text like the language. This is a major aspect of weakness for the cipher.</span>

			<h2>Symbol Map Cipher</h2>
			This cipher uses a technique that does not neccesarily have to be used as a cipher, but for our means will be used as one. There are several instances of websites being capable of mapping one symbol to another, such as Unicode font websites (<a href="https://www.textconverter.net/?text=abc">Text Converter</a>, <a href="https://convertcase.net/unicode-text-converter/">Convert Case</a>, <a href="https://texteditor.com/font-converter/">Text Editor</a>). The symbols used in the sites are designed to be legible to an individual who can read the Latin alphabet, but for the purposes of ciphering, we can use this technique to instead subsitute unreadable symbols into a normal piece of text.<br><br>

			For example, we can subsitute "[" for "a", "]" for "b", and "." for "c". So, "abcccaaabab" would be "[]...[[[][]". These characters do not have any resemblance to the original "abc" letters used.<br>
			We can extend this to the entire alphabet if we have a set of symbols to match each alphabetical character. However, this cipher does not have to match only the alphabet. By feeding both a set of character to convert from as well as a set of characters to convert to, we can create a key to convert to and from ciphered and unciphered text.<br><br>

			This type of cipher can expand the limits of the subsitution cipher. There are several subsitution techniques which can help in reducing the weakness of traditional subsitution ciphers, more specifically <a href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a>.
			<ul>
				<li>Polygraphic - Instead of converting from one character to another, it is possible to convert multiple characters into a singular cipher symbol. For example, "aa" could translate to "0", and "ab" could translate to ".", and etc.</li>
				<li>Homophonic - This method can represent one symbol with multiple different alternate possibilities. For example, "a" could cipher into "[" or "]" or "{" or "}", with all of these possible results translating back into "a".</li>
			</ul>

			Utilizing these concepts, we can create special keys to strengthen a traditionally 1-1 key.

			<h3>Alphabet Keys</h3>

			The first part of our ciphers are the alphabet keys. These contain all of the symbols from an unciphered string you convert into ciphered text. With a custom syntax, we can create a special alphabet to convert from:<br>
			<dl>
				<dt>
					<code class="block">
						abcdefABC
					</code><br>
					<code class="block">
						fghAS
					</code>
				</dt>
				<dd>
					This is the default notation for creating an alpabet key, you input all characters you want to have in the alphabet key. For the first case, only the letters "abcdefABC" will be ciphered. For the most basic 1-1 key, that means you have 9 cipher symbols, one for each letter. All characters not in this alphabet key, such as spaces, numbers, newlines, diacritic letters, etc, will be left out and unciphered.
				</dd>
				<dt>
					<code class="block">
						alphabet-standard
					</code>
				</dt>
				<dd>
					The alphabet key "alphabet-standard" translates to all 52 lowercase and uppercase letters of the alphabet.
				</dd>

				<dt>
					<code class="block">
						alpha-numeric
					</code>
				</dt>
				<dd>
					The alphabet key "alpha-numeric" translates to all 52 lowercase and uppercase letters of the alphabet with the addition of 10 numbers, resulting in 62 characters in total.
				</dd>
				<dt>
					<code class="block">
						full-set
					</code>
				</dt>
				<dd>
					The alphabet key "full-set" translates to the entire alphabet, its numbers, and every basic keyboard symbol (more specifically ASCII characters 32-126), INCLUDING the newline (ASCII character 10). This is 96 characters in total.
				</dd>
				<dt>
					<code class="block">
						case:abcdefABC
					</code><br>
					<code class="block">
						case:fghAS
					</code><br>
					<code class="block">
						case:alphabet-standard
					</code><br>
					<code class="block">
						case:alpha-numeric
					</code>
				</dt>
				<dd>
					By prefixing with "case:", the key will become case-insensitive, either for a custom alphabet key or a pre-made alphabet key.<br>
					Single-case alphabet-standard is 26 letters.<br>
					Single-case alpha-numeric is 36 letters.<br>
					Single-case full-set is 70 letters.
				</dd>
				<dt>
					<code class="block">
						a,b,cd,EF,abc
					</code><br>
					<code class="block">
						fgh,AS
					</code><br>
					<code class="block">
						a,b,.,\,
					</code><br>
					<code class="block">
						a,b,.,\\
					</code><br>
				</dt>
				<dd>
					The default notation can be altered in order to group symbols together, creating a polygraphic cipher. For example, if we mapped to the "[", "]", ".", "{", and "}" symbols using the first alphabet key, the string "I know the ways of the abc, EFcd" would transform into "I know the w[ys of the }, {.". Note that longer strings of symbols take priority over shorter symbols, hence why we can match "abc" with "}" and not get the result "[]c".<br>
					Because commas are a reserved symbol in an alphabet key, they must be escaped with "\" ("\,") as shown in the third key. Because backspaces are also a reserved symbol thanks to this functionality, they must also be escaped with "\" ("\\") as shown in the fourth key.
				</dd>
				<dt>
					<code class="block">
						bigraphic:standard-alphabet
					</code><br>
					<code class="block">
						trigraphic:case:alpha-numeric
					</code>
				</dt>
				<dd>
					By prefixing any previous notation with "bigraphic:" or "trigraphic:", we can get an automatically generated bigraphic or trigraphic cipher using all possible symbol combinations in a two-length or three-length block. This results in a symbol set that is either squared or cubed the size of the original symbol set.<br>
					For the first key example, because the standard-alphabet set is 52 letters, we get an alphabet key of 2704 symbols since that is 52 squared.<br>
					For the second key example, because the single-case alpha-numeric set is 36 letters, we get an alphabet key of 46656 symbols since that is 36 cubed.<br>
					That means for either of those ciphers, you will need 2704 or 46656 unique cipher symbols respectively to have a complete cipher, which can be extremely difficult if you do not have the tools to gather and organize that many unique symbols.
				</dd>
			</dl>

			<h3>Cipher Keys</h3>

			Everything demonstrated above is a great and wide variety for alphabet keys, but this does not even include the second half of the ciphering, which are the cipher keys. These are the symbols you want your resulting cipher to have.

			<dl>
				<dt>
					<code class="block">
						[]{}.?
					</code><br>
					<code class="block">
						!@#$%^
					</code>
				</dt>
				<dd>
					Like the alphabet keys, the basic and standard notation to convert from alphabet keys to cipher keys uses no spaces, and each individual character is parsed as a seperate ordered key.<br>
					If we had an alphabet key of <code class="block">abcdef</code> and a cipher key of <code class="block">[]{}.?</code>, then the string "I am the cat of the rats" is ciphered into "I [m th. {[t o? th. r[ts". All symbols not found in the original alphabet key are untouched, and all symbols that <span style="font-style: italic;">are</span> found are replaced with their counterpart in the specific order they come in.
				</dd>
				<dt>
					<code class="block">
						[],(),{},<>
					</code><br>
				</dt>
				<dd>
					We are capable of defining more than one symbol at a time to replace a ciphered character, seperated by commas. In this case, if we had an alphabet key of <code class="block">acer</code> and a cipher key of <code class="block">[],(),{},<></code>, then the string "I can count to three!" is ciphered into "I ()[]n ()ount to th<>{}{}!".<br>
					In cipher keys, commas and backslashes are handled in the same way that they are with the alphabet keys, being escaped with a backslashed behind them.
				</dd>
				<dt>
					<code class="block">
						[|],(|),{|},<|>
					</code><br>
				</dt>
				<dd>
					This cipher key uses the "pipe" symbol "|" to introduce homophony, allowing multiple alternative symbols to appear in the case of a single character. In this case, if we had an alphabet key of <code class="block">acer</code> and a cipher key of <code class="block">[|],(|),{|},<|></code>, then we can have an original string:<br>
					<code class="block">
						"I can count to three!" (original)
					</code><br>
					And cipher variants of said string below can be valid:<br>

					<code class="block">
						"I )[n (ount to th{&gt;&lt;!" (ciphered 1)<br>
						"I )]n )ount to th}&lt;&gt;!" (ciphered 2)<br>
						"I ([n )ount to th{&lt;&lt;!" (ciphered 3)
					</code><br>
					In the case that homophony is used, all homophonic symbols will have an equal randomly generated chance of appearing.<br><br>
					The pipe symbol must also be escaped in cipher keys to be used on its own due to its reserved meaning.
				</dd>
			</dl>

			<h3>Benefits and Drawbacks</h3>
			Depending on who uses the cipher and how, it can be a very strong cipher. The keys for this cipher can vary very heavily, it has support for all Unicode symbols for both encoding and decoding, and it introduces concepts which can help thwart <a href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a>.<br><br>
			A very interesting property of being able to use any Unicode character you desire in the cipher key is that you can intentionally utilize the <a href="#unusual-behavior">unusual behavior</a> of certain symbols when it comes to rendering text. Certain characters appear so small that it is very difficult to seperate them just by looking at them or by using your cursor to select them, and certain symbols have no width at all, making them invisible at a glance as if there were no symbols there in the first place. Common characters like spaces or vowels could be repalced with these anomolous characters to provide a disorienting first-glance at the ciphered text.

			<!-- <h2>Custom Equation Cipher</h2> -->
		</div>
		<!-- <div class="section">
			<h1>Section header</h1>


		</div> -->
	</div>

	<script src="init.js"></script>

	<script>
	</script>

</body>
</html>
